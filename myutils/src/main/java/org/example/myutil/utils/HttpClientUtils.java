package org.example.myutil.utils;import javax.net.ssl.*;import java.io.IOException;import java.net.Socket;import java.net.URI;import java.net.URLEncoder;import java.net.http.HttpClient;import java.net.http.HttpRequest;import java.net.http.HttpResponse;import java.nio.charset.StandardCharsets;import java.rmi.RemoteException;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.time.Duration;import java.util.*;import java.util.logging.Level;import java.util.logging.Logger;import java.util.stream.Collectors;/** * @author hzhq1255 * @version 1.0 * @since 2022-11-26 下午10:46 * <p> * accept application/json */public class HttpClientUtils {    private static final Logger LOGGER = Logger.getLogger("httpClientUtils");    public static HttpResponse<String> doGet(String url, Map<String, String> query) throws IOException, InterruptedException {        return sendRequest(HttpMethod.GET, url, null, query, null, String.class);    }    public static HttpResponse<String> doGet(String url, Map<String, String> headers, Map<String, String> query) throws IOException, InterruptedException {        return sendRequest(HttpMethod.GET, url, headers, query, null, String.class);    }    public static <T> HttpResponse<T> doGet(String url, Map<String, String> headers, Map<String, String> query, Class<T> clazz) throws IOException, InterruptedException {        return sendRequest(HttpMethod.GET, url, headers, query, null, clazz);    }    public static HttpResponse<String> doPost(String url, Map<String, String> headers, Map<String, String> query, String body) throws IOException, InterruptedException {        return sendRequest(HttpMethod.POST, url, headers, query, body, String.class);    }    public static <T, E> HttpResponse<E> doPost(String url, Map<String, String> headers, Map<String, String> query, T body, Class<E> clazz) throws IOException, InterruptedException {        return sendRequest(HttpMethod.POST, url, headers, query, body, clazz);    }    public static HttpResponse<String> doPostForm(String url, Map<String, String> headers, Map<String, String> query, String body) throws IOException, InterruptedException {        return sendRequest(HttpMethod.POST, url, mergeContentTypeHeader(headers, HeaderContentType.URL_FORM_DATA), query, body, String.class);    }    public static HttpResponse<String> doPostJson(String url, Map<String, String> headers, Map<String, String> query, String body) throws IOException, InterruptedException {        return sendRequest(HttpMethod.POST, url, mergeContentTypeHeader(headers, HeaderContentType.APPLICATION_JSON), query, body, String.class);    }    public static HttpResponse<String> doPut(String url, Map<String, String> headers, Map<String, String> query, String body) throws IOException, InterruptedException {        return sendRequest(HttpMethod.PUT, url, headers, query, body, String.class);    }    public static <T, E> HttpResponse<E> doPut(String url, Map<String, String> headers, Map<String, String> query, T body, Class<E> clazz) throws IOException, InterruptedException {        return sendRequest(HttpMethod.POST, url, headers, query, body, clazz);    }    public static HttpResponse<String> doPutJson(String url, Map<String, String> headers, Map<String, String> query, String body) throws IOException, InterruptedException {        return sendRequest(HttpMethod.PUT, url, mergeContentTypeHeader(headers, HeaderContentType.APPLICATION_JSON), query, body, String.class);    }    public static HttpResponse<String> doDelete(String url, Map<String, String> query) throws IOException, InterruptedException {        return sendRequest(HttpMethod.DELETE, url, null, query, null, String.class);    }    public static HttpResponse<String> doDelete(String url, Map<String, String> headers, Map<String, String> query) throws IOException, InterruptedException {        return sendRequest(HttpMethod.DELETE, url, headers, query, null, String.class);    }    public static <T> HttpResponse<T> doDelete(String url, Map<String, String> headers, Map<String, String> query, Class<T> clazz) throws IOException, InterruptedException {        return sendRequest(HttpMethod.DELETE, url, headers, query, null, clazz);    }    private static HttpClient getHttpClient(String url) {        return Optional.ofNullable(url)                .filter(u -> url.startsWith("https://"))                .map(u -> sslClient)                .orElse(normalClient);    }    private static <T, E> HttpResponse<E> sendRequest(HttpMethod method, String url, Map<String, String> headers, Map<String, String> query, T body, Class<E> clazz) throws IOException, InterruptedException {        try {            return getHttpClient(url)                    .send(buildRequest(method, url, headers, query, body),                            getBodyHandler(clazz));        } catch (IOException | InterruptedException e) {            LOGGER.log(Level.WARNING, String.format("request %s %s failed", method, url), e);            throw e;        }    }    private static <T> HttpRequest buildRequest(HttpMethod method, String url, Map<String, String> headers, Map<String, String> query, T body) {        boolean isHeaderEmpty = Optional.ofNullable(headers).map(Map::isEmpty).orElse(true);        URI uri = mergeUrlAndQuery(url, query);        String[] headersArr = getHeadersAsStringArray(headers);        System.out.println(String.join(";", headersArr));        switch (method) {            case GET:                return isHeaderEmpty ?                        HttpRequest.newBuilder()                                .uri(uri)                                .GET()                                .build()                        :                        HttpRequest.newBuilder()                                .uri(uri)                                .headers(headersArr)                                .GET()                                .build();            case POST:                return isHeaderEmpty ?                        HttpRequest.newBuilder()                                .uri(uri)                                .POST(getBodyPublisher(body))                                .build()                        :                        HttpRequest.newBuilder()                                .uri(uri)                                .headers(headersArr)                                .POST(getBodyPublisher(body))                                .build();            case PUT:                return isHeaderEmpty ?                        HttpRequest.newBuilder()                                .uri(uri)                                .PUT(getBodyPublisher(body))                                .build()                        :                        HttpRequest.newBuilder()                                .uri(uri)                                .headers(headersArr)                                .PUT(getBodyPublisher(body))                                .build();            case PATCH:                return isHeaderEmpty ?                        HttpRequest.newBuilder()                                .uri(uri)                                .method("PATCH",getBodyPublisher(body))                                .build()                        :                        HttpRequest.newBuilder()                                .uri(uri)                                .headers(headersArr)                                .method("PATCH",getBodyPublisher(body))                                .build();            case DELETE:                return isHeaderEmpty ?                        HttpRequest.newBuilder()                                .uri(uri)                                .DELETE()                                .build()                        :                        HttpRequest.newBuilder()                                .uri(uri)                                .headers(headersArr)                                .DELETE()                                .build();            default:                throw new UnsupportedOperationException(String.format("unsupported method %s", method));        }    }    private static <T> HttpRequest.BodyPublisher getBodyPublisher(T body) {        Class<T> clazz = body == null ? null : (Class<T>) body.getClass();        if (clazz == null) {            return HttpRequest.BodyPublishers.noBody();        } else if (clazz == String.class) {            return HttpRequest.BodyPublishers.ofString((String) body, StandardCharsets.UTF_8);        } else if (clazz == byte[].class) {            return HttpRequest.BodyPublishers.ofByteArray((byte[]) body);        } else {//            return HttpRequest.BodyPublishers.noBody();            throw new UnsupportedOperationException(String.format("unsupported body %s", body.getClass()));        }    }    private static <T> HttpResponse.BodyHandler<T> getBodyHandler(Class<T> clazz) {        if (clazz == null) {            return (HttpResponse.BodyHandler<T>) HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8);        } else if (clazz == String.class) {            return (HttpResponse.BodyHandler<T>) HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8);        } else if (clazz == byte[].class) {            return (HttpResponse.BodyHandler<T>) HttpResponse.BodyHandlers.ofByteArray();        } else {//            return HttpRequest.BodyPublishers.noBody();            throw new UnsupportedOperationException(String.format("unsupported return type %s", clazz));        }    }    private static URI mergeUrlAndQuery(String url, Map<String, String> query) {        return URI.create(Optional.ofNullable(url)                .map(u -> u + getQueryAsString(query))                .orElse(""));    }    private static String getQueryAsString(Map<String, String> query) {        return (Optional.ofNullable(query).isPresent() ? "?" : "") +                Optional.ofNullable(query)                        .map(Map::entrySet)                        .orElse(new HashSet<>())                        .stream()                        .map(e -> String.format("%s=%s", URLEncoder.encode(e.getKey(), StandardCharsets.UTF_8),                                URLEncoder.encode(e.getValue(), StandardCharsets.UTF_8)))                        .collect(Collectors.joining("&"));    }    private static Map<String, String> mergeContentTypeHeader(Map<String, String> headers, String contentType) {        Map<String, String> headerMap = Optional.ofNullable(headers).orElse(new HashMap<>())                .entrySet()                .stream()                .collect(Collectors.toMap(e -> e.getKey().toLowerCase(), e -> e.getValue().toLowerCase()));        System.out.println(headerMap);        if (!Objects.equals(headerMap.get("content-type"), contentType)) {            headerMap.put("content-type", contentType);            return headerMap;        }        return headerMap;    }    private static String[] getHeadersAsStringArray(Map<String, String> headers) {        return Optional.ofNullable(headers)                .map(Map::entrySet)                .orElse(new HashSet<>())                .stream()                .map(e -> new ArrayList<String>(){{                    add(e.getKey());                    add(e.getValue());                }})                .flatMap(List::stream)                .toArray(String[]::new);    }    private static final HttpClient sslClient;    private static final HttpClient normalClient;    static {        System.setProperty("jdk.internal.httpclient.disableHostnameVerification", "true");//取消主机名验证        SSLParameters sslParams = new SSLParameters();        sslParams.setEndpointIdentificationAlgorithm("");        SSLContext sc;        try {            sc = SSLContext.getInstance("SSL");        } catch (NoSuchAlgorithmException e) {            throw new RuntimeException("init ssl context error");        }        try {            sc.init(null, HttpProps.trustAllCertificates, new SecureRandom());        } catch (KeyManagementException e) {            throw new RuntimeException("init ssl context error");        }        sslClient = HttpClient.newBuilder()                .version(HttpProps.DEFAULT_HTTP_VERSION)                .sslContext(sc)                .sslParameters(sslParams)                .connectTimeout(Duration.ofSeconds(HttpProps.DEFAULT_CONNECTED_TIME_OUT_SECONDS))                .build();        normalClient = HttpClient.newBuilder()                .version(HttpProps.DEFAULT_HTTP_VERSION)                .connectTimeout(Duration.ofSeconds(HttpProps.DEFAULT_CONNECTED_TIME_OUT_SECONDS))                .build();    }    private enum HttpMethod {        GET,        POST,        PUT,        PATCH,        DELETE,    }    private static class HeaderContentType {        public static final String APPLICATION_JSON = "application/json";        public static final String URL_FORM_DATA = "application/x-www-form-urlencoded";    }    private static class HttpProps {        public static final Integer DEFAULT_CONNECTED_TIME_OUT_SECONDS = 5;        public static final HttpClient.Version DEFAULT_HTTP_VERSION = HttpClient.Version.HTTP_1_1;        public static final TrustManager[] trustAllCertificates = new TrustManager[]{new X509ExtendedTrustManager() {            @Override            public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) {            }            @Override            public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) {            }            @Override            public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) {            }            @Override            public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) {            }            @Override            public void checkClientTrusted(X509Certificate[] chain, String authType) {            }            @Override            public void checkServerTrusted(X509Certificate[] chain, String authType) {            }            @Override            public X509Certificate[] getAcceptedIssuers() {                return null;            }        }};    }}